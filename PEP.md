
# Never Write React Boilerplate Ever Again

Modern state management libraries like React and Redux are extremely powerful solutions for building front-end applications, but come with some significant pain points with respect to the amount of boilerplate code required for each library to compile and run.  Between Webpack, Babel, tracking various dependencies, component definitions, component mounting, component lifecycles, and all the related connection code, "This is my React Hello World" has been a running joke/meme/frustration that has grown alongside the popularity of the framework. Indeed, with the release of React Hooks, which explicitly aims to reduce component complexity, "the boilerplate problem" appears to be influencing the evolution of the framework itself.

Borrowing from the Angular ecosystem, which has an officially maintained and extensive CLI, in 2016 the React team released "create-react-app" ("CRA") a library which allowed developers to generate entire React projects, and drove wider adoption of the framework despite its verbosity. Yet, as projects grow, and developers become more experienced in the framework, CRA begins to create another set of problems around its easy of use, which forces users to trade convenince for a decreased ability to control and configure the underlying packages which power their applications. Around the third minute of the first install, it also becomes clear that CRA is quite "bureaucratic," weighing in at 300 mbs, with dozens of libraries, and no less than two separate servers out of the box. It does come with a cool spinning icon when you boot the landing page though! 

Whats more, while it provides a kind of 'command line' solution to one set of problems- initializing a React application- it doesn't necessarily solve another set of problems- writing the application itself. Class components, stateless functional components, life-cycle methods, and now other, advanced functional/hook components- React's boilerplate requirements do not end after hello world is achieved.  One solution which I have used is the "React ES6 Snippets" library, which I like, but grew frustrated at during the third or fourth hour of trying to edit the Sublime codebase.

So, using Node.js and npm, lets build our own CLI that will have methods to access and edit the required configuration files- Webpack, Babel, package.json, etc- as well as methods to generate some useful component code. This will give us the immediate hello world of CRA without sacrificing flexiblility, so that when we want to tweak our template, or the next time Facebook updates React, we can iterate on the code as we like. 

Sound good? Lets get started.

First step: google "react boilerplate medium" and copy the code from the first thing that pops up. Just kidding! I'll do that for you in a bit, but since we're not just making some boilerplate, but making a CLI that will write source code files, the first thing we need to do is set up our CLI.

Do:

```bash 
mkdir react-boiler
npm init -y
```

So, what do we want? We want to be able to call the command line and generate a project scaffold: folders, connection code, and all the boilerplate files that a modern React requires inserted into the proper folders. Ideally, we would run our bash command, something like "scaffold," then "npm run start-dev," and everything would be ready to go, just like CRA.

So, first things first. In order to make a command available in Bash, we need to install this package globally, and have npm add the command to its "/bin" directory inside the shell PATH. 

Lets create a the file for the scripts we want to run when we run our bash commands:

```bash
$: touch cli.js
```

Then, in the package.json file generated by the npm init call, insert the following under "license":

```json
"bin": {
    "react": "./cli.js"
  },
``` 

Since I don't have "react" in my PATH namespace, I'm just going to have our library callable as "react." 

Then, run the command to install our package globally: 

```bash
$: npm install -g ./
```

To confirm that 'react' was added to node's bin directory, call:

```bash
$: which react
```
Bash should output node's global module directory in your PATH.

Next, lets configure the cli.js file. In order for Bash to know what program needs to execute the script when we call our react command, insert the following at the top of the file:

```shell
#!/usr/bin/env node
```

Put a console log inside cli.js, then call 'react' in the command line, and test that everythings working. 

Its working?  I bet at some point you've wondered how other packages like nodemon get hoisted to run globally from the command line. This is one way. Pretty cool right?

So before we write configuration files, we will want node to create our project template. 

What if node could run bash commands like "mkdir"? That's sometimes called "shelling out," and there are several node methods we can use to do this. We're going to use "spawn," because that sounds cooler than the other shell out methods. 

In cli.js :

```js
const { spawn } = require('child_process')
let input = process.argv
let command = input[2]
let arg1 = input[3]
```

"Process.argv" is an array that represents the arguments passed into the specific node process from the command line call ("process.argv[0]" being node itself).

We're going to shell out a few times, so lets make a helper method:

```js
const shell = (command) => {

  spawn(command, {shell: true, 
                  cwd: process.cwd()
                 }
        )
}
````

Now, our shell() method will run any command we pass to it in bash. Since we want to operate on other folders on our machine, we're going to set spawn's working directory as "cwd()."

Now we can program "react scaffold" to make a file directory like this:

```js

if(command === 'scaffold'){

  let makeDirectory = shell('mkdir src')
}
````

Call "react scaffold" in Bash, and you should see a src folder pop up. 

Now that we have a src code folder, lets write the configuration files in the other two dozen Medium articles about React boilerplate: webpack, babelrc, and the gigantic package.json- as well as the components of a React web app: index.html and a js entry point like main.js. 

And put this these in a folder called "src," since they're really the boilerplate source code for our upcoming projects.

```bash
mkdir src src/public src/app
touch src/webpack.config.js src/babelrc src/package.json src/server.js src/public/index.html src/public/style.css src/app/main.js 

```

Inside the webpack config file:

```js
const { resolve } = require('path')

module.exports = {
  entry: ['babel-polyfill', './app/main'],
  output: {
    path: __dirname,
    filename: './public/bundle.js'
  },
  mode: 'development',
  context: __dirname,
  devtool: 'source-map',
  resolve: {
    extensions: ['.js', '.jsx']
  },
  module: {
    rules: [
      {
        test: /jsx?$/,
        include: resolve(__dirname, './app'),
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  }
}
```

Inside the babel config file:

```json
{
  "presets": ["react", "env", "stage-2"]
}
```

Inside the package.json: 

```json
{
  "name": "",
  "version": "1.0.0",
  "description": "",
  "main": "app/main.js",
  "scripts": {
    "start-dev": "npm run build-watch & npm run start-server",
    "start-server": "nodemon -L --watch server main.js -e html,js,css",
    "build-watch": "webpack -w",
    "start": "echo 'Running server for production - developers, use npm run start:dev for development' && node main"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.18.0",
    "body-parser": "^1.18.2",
    "express": "^4.14.0",
    "react": "^16.3.2",
    "react-dom": "^16.3.2",
    "react-redux": "^5.0.7",
    "react-router-dom": "^4.2.2",
    "redux": "^4.0.0",
    "redux-devtools-extension": "^2.13.7",
    "redux-logger": "^3.0.6",
    "redux-thunk": "^2.2.0"
  },
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-eslint": "^8.2.3",
    "babel-loader": "^7.1.4",
    "babel-polyfill": "^6.26.0",
    "babel-preset-env": "^1.7.0",
    "babel-preset-react": "^6.24.1",
    "babel-preset-stage-2": "^6.24.1",
    "css-loader": "^0.28.11",
    "eslint": "^4.19.1",
    "eslint-plugin-react": "^7.8.2",
    "style-loader": "^0.21.0",
    "webpack": "^4.29.6",
    "webpack-cli": "^3.2.3"
  }
}
```

Inside index.html: 
```HTML 
<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>

    <div id="root"></div>
    <script async defer src="/bundle.js"></script>    
  
  </body>
</html> 
```

Inside main.js:
```js
import React from 'react'
import { render } from 'react-dom'

const Root = () => {

  return ( 
    <div> 
    Goodbye World! 
    </div>
  )
}

render(
   <Root />,
  document.getElementById('root')
);
````

So now that we have our source project, how are we going to automate over copying and pasting this into a new set of files in our next project? 

Returning to our cli.js file, re-write our scaffold conditional:

```js
if(command === 'scaffold'){

  console.log(process.cwd())

}
```

Make sure you've navigated to the project folder containing the src folder, and run "react scaffold." 

Ok...you could also just:

```bash
pwd
```
We need the exact path to the "project" file.

Replace the console log, copy and paste the file path along with the following shell method:

```js

let sourceDirectory = '/Users/...' // whatever the path is

if(command === 'scaffold'){

  shell(`cp -a ${sourceDirectory}/. . `)
}
```

Breaking down the shell command, '-a' is a recursive option, which tells Bash to access the entire subfolder, which is why "src" needed to be inside another folder called "project." The first argument is the source folder, which is what we defined as the source directory, and the second argument is '.', or the current working directory we defined in our shell method. 

Now, create and navigate into a test directory, then run "react scaffold". The contents of the src folder should populate. 

Now run: 
```bash
$ npm i
$ npm run build
```

This will run webpack, which should hash a bundled js file without any issues.

Finally, lets make a method that will allow us to iterate on this codebase quickly, so we can update our next project.

Based on the fact that we've stored an exact file path to the source directory in our cli.js file, its pretty simple to make a shortcut command to edit the entire folder in our code editor.

```js

let sourceDirectory = '/Users/...' // whatever the path is

if(command === 'scaffold'){

  shell(`cp -a ${sourceDirectory}/. . `)
}

if(command === 'edit'){

  shell(`subl ${pwd}`)
}

```

This will automatically launch the folder in Sublime (the editor I use), and for VSC Code it would just be "code"

Mozel tov internet friend. Does this all seem a bit basic?  Think about what we just did: now you have a hello world React app that you can summon from the command line, that you can completely control and customize, and that you can easily iterate over and improve with each project.  

You want to magically summon a full GraphQL API with your hello world React app? Just add it into the src file, or create separate projects and configure them with separate command line calls. Want to configure an entire Redux store with React Router and Semantic UI? Just add it into the src file.
