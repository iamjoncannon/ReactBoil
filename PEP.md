
# Never Write React Boilerplate Ever Again

Modern state management libraries like React and Redux are extremely powerful tools for building front-end applications, but come with some significant pain points with respect to the amount of boilerplate code required for each library to compile and run.  Between Webpack, Babel, tracking various dependencies, component definitions, component mounting, component lifecycles, and all the related connection code, "This is my React Hello World" has been a running joke/meme/frustration that has grown alongside the popularity of the framework. Indeed, with the release of React Hooks, which explicitly aims to reduce component complexity, "the boilerplate problem" appears to be influencing the evolution of the library itself.

Borrowing from the Angular ecosystem, which has an officially maintained and extensive CLI, in 2016 the React team released "create-react-app" ("CRA") a library which allowed developers to generate entire React projects, and drove wider adoption of the framework despite its verbosity. Yet, as projects grow, and developers become more experienced in the framework, CRA begins to create another set of problems around its easy of use, which forces users to trade convenince for a decreased ability to control and configure the underlying packages which power their applications. Around the third minute of the first install, it also becomes clear that CRA is quite "bureaucratic," weighing in at 300 mbs, and no less than two separate servers out of the box, whose configuration, side effects, and limitations take time and energy to disentangle. Talk to a someone with React experience, and they will almost all have some sort of rant related to debugging CRA. It does come with a cool spinning icon when you boot the landing page though! 

Whats more, while it provides a kind of 'command line' solution to one set of problems- initializing a React application- it doesn't necessarily solve another set of problems- writing the application itself. Class components, stateless functional components, life-cycle methods, components connected to a Redux store, and now other, advanced functional/hook components- React's boilerplate requirements do not end after hello world is achieved.  One solution which I have used is the "React ES6 Snippets" library, which I like, but grew frustrated at during the third or fourth hour of trying to edit the Sublime codebase.

So, using Node.js and npm, lets build our own CLI that will have methods to summon the required configuration files- Webpack, Babel, package.json, etc- as well as methods to generate some useful component files. This will give us the immediate hello world of CRA and the immediate boilerate of snippets without sacrificing flexiblility, so that when we want to tweak our templates, or the next time React gets updated, we can iterate on the code as we like, quickly and easily.

Sound good? Lets get started.

First step: google "react boilerplate medium" and copy the code from the first thing that pops up. Just kidding! I'll do that for you in a bit. 

Since we're not just making some boilerplate, but making a CLI that will generate source code files, the first thing we need to do is set up a script thats available from the command line.

Do:

```bash 
mkdir react-boiler 
cd react-boiler  
npm init -y
```

So, what do we want? We want to be able to call the command line and generate a project scaffold: folders, connection code, and all the boilerplate files that a modern React requires inserted into the proper folders. Ideally, we would run our bash command, something like "scaffold," then "npm run start-dev," and everything would be ready to go, just like CRA.

So, first things first. In order to make a command available in Bash, we need to install this package globally, and have npm add the command to its "bin" directory inside the shell PATH. 

<digression> 

Now (some of you are probably thinking) we could also do this by inserting an alias inside our Bash profile. In order to build out some of the other functionality, we would have to code the rest of the alias functions in Bash, which is (I've been told) a C abstraction, which most of you don't know (and neither do I). I think keeping our code inside the Node/npm/JS ecosystem is the best strategy, and will allow your boilerplate to grow and get customized easily over time.  

</digression>

Anyway, lets create a the file for the scripts we want to run when we call our Bash commands:

```bash
touch cli.js
```

Then, in the package.json file generated by the npm init call, insert the following under "license":

```json
"bin": {
    "react": "./cli.js"
  },
``` 

Since I don't have "react" in my PATH namespace, I'm just going to have our library available as "react." 

Run the command to install our package globally: 

```bash
npm install -g ./
```

To confirm that 'react' was added to node's bin directory, call:

```bash
which react
```
Bash should output node's global module directory in your PATH.

Next, lets configure the cli.js file. In order for Bash to know what program needs to execute the script when we call our react command, insert the following at the top of the file:

```shell
#!/usr/bin/env node
```

Put a console log inside cli.js, then call 'react' in the command line, and test that everythings working. 

Its working?  I bet at some point you've wondered how other packages like nodemon get hoisted to run globally from the command line. This is one way. Pretty cool right?

Next, what if node could run bash commands like "cp," for us to automatically locate and copy a file directory? That's sometimes called "shelling out," and there are several ways we can use to do this in node. We're going to use "spawn," because that sounds cooler than the other shell out methods. 

In cli.js :

```js
const { spawn } = require('child_process')
let input = process.argv
let command = input[2]
```

"Process.argv" is an array that represents the arguments passed into the specific node process from the command line call ("process.argv[0]" being node itself).

We're going to shell out a few times, so lets make a helper method:

```js
const shell = (command) => {

  spawn(command, {shell: true, 
                  cwd: process.cwd()
                 }
        )
}
````

Now, our shell() method will run any command we pass to it in Bash. Since we want to operate on other folders on our machine, we're going to set spawn's working directory as "process.cwd()," which will return the destination for our template. 

Now we can program "react scaffold" to make a file directory like this:

```js

if(command === 'scaffold'){

  let makeDirectory = shell('mkdir src')
}
````

Now do:
```Bash
react scaffold 
```

You should see a src folder pop up. Ok you could have called mkdir in Bash. But that was kind of fun, right?

Anyway, now that we have a src code folder, lets write the configuration files in the other two dozen Medium articles about React boilerplate: webpack, babelrc, and the gigantic package.json- as well as the components of a React web app: index.html, a js entry point like main.js, and a basic Express dev server. 

```bash
mkdir src/public src/app
touch src/webpack.config.js src/babelrc src/package.json src/server.js src/public/index.html src/public/style.css src/app/main.js 

```

Here's the part where you copy and paste all the boilerplate code.

Inside the webpack config file:

```js
const { resolve } = require('path')

module.exports = {
  entry: ['babel-polyfill', './app/main'],
  output: {
    path: __dirname,
    filename: './public/bundle.js'
  },
  mode: 'development',
  context: __dirname,
  devtool: 'source-map',
  resolve: {
    extensions: ['.js', '.jsx']
  },
  module: {
    rules: [
      {
        test: /jsx?$/,
        include: resolve(__dirname, './app'),
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  }
}
```

Inside the babel config file (I always forget this one):

```json
{
  "presets": ["react", "env", "stage-2"]
}
```

Inside the package.json: 

```json
{
  "name": "",
  "version": "1.0.0",
  "description": "",
  "main": "app/main.js",
  "scripts": {
    "start-dev": "npm run build & npm run start-server",
    "start-server": "nodemon -L --watch server.js -e html,js,css",
    "build": "webpack -w",
    "start": "echo 'Running server for production - we're using npm run start-dev for development folks' && node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.18.0",
    "body-parser": "^1.18.2",
    "express": "^4.14.0",
    "react": "^16.8.4",
    "react-dom": "^16.3.2",
    "react-redux": "^5.0.7",
    "react-router-dom": "^4.2.2",
    "redux": "^4.0.0",
    "redux-devtools-extension": "^2.13.7",
    "redux-logger": "^3.0.6",
    "redux-thunk": "^2.2.0"
  },
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-eslint": "^8.2.3",
    "babel-loader": "^7.1.4",
    "babel-polyfill": "^6.26.0",
    "babel-preset-env": "^1.7.0",
    "babel-preset-react": "^6.24.1",
    "babel-preset-stage-2": "^6.24.1",
    "css-loader": "^0.28.11",
    "eslint": "^4.19.1",
    "eslint-plugin-react": "^7.8.2",
    "style-loader": "^0.21.0",
    "webpack": "^4.29.6",
    "webpack-cli": "^3.2.3"
  }
}

```

I left in Redux. 

Inside index.html: 
```HTML 
<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>

    <div id="root"></div>
    <script async defer src="/bundle.js"></script>    
  
  </body>
</html> 
```

Inside main.js:
```js
import React from 'react'
import { render } from 'react-dom'

const Root = () => {

  return ( 
    <div> 
    Goodbye World! 
    </div>
  )
}

render(
   <Root />,
  document.getElementById('root')
);
````

Inside server.js:
```js
const express = require('express')
const app = express()
const path = require('path')
const PORT = process.env.PORT || 1337

app.use(express.json())
app.use(express.urlencoded({ extended: true }))
app.use(express.static(path.join(__dirname, './public')))

app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, './public/index.html'))
}) 

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(err.status || 500).send(err.message || 'Internal server error')
})

app.listen(PORT, () => console.log(`serving on port ${PORT}`))

```

So now that we have our source project, how are we going to quickly transport this into a new set of files in our next project? 

Returning to our cli.js file, re-write our scaffold conditional:

```js
if(command === 'scaffold'){

  console.log(process.cwd())

}
```

Make sure you've navigated to the project folder containing the src folder, and run "react scaffold." 

Ok...again you could also do:

```bash
pwd
```
We just need the exact system path to the "project" file.

Replace the console log, insert the file path along with the following shell call:

```js
const { spawn } = require('child_process')
let input = process.argv
let command = input[2]

let sourceDirectory = '/Users/...' // the file directory location

if(command === 'scaffold'){

  shell(`cp -a ${sourceDirectory}/. .`)
}
```

Breaking down the shell command, '-a' tells Bash to access the subfolder recursively. The first argument is the source folder, which is what we defined as the source directory, and the second cp argument is the destination directory, '.', or the directory that we would be in when we make the 'react scaffold' call. This was why we had to pass process.cwd() to our helper shell function above, and the entire reason why this will save you time in the future. No need to dig through your directories and find your last project, or that thing you found on Medium that one time, or the code from that Udemy course you did a few months ago. Just run the command and Bash will summon your template.  

Create and navigate into a test directory, then run "react scaffold". The contents of the src folder should populate. 

Inside src, do: 
```bash
npm i
npm run start-dev
```

This will run webpack in watch mode, which should hash the bundled js file without any issues, then boot our Express development server. Navigate to localhost:1337, and we have our React Hello World.

So this was pretty straightforward. We made some files and did a Bash trick to dump them where we wanted them. 

Lets do something a bit more complex. What if we could automatically generate multiple component files from one command line call?

Something like:
```Bash

react make cont Navbar pres Widget Link Dropdown
```
So what do we want:  

1) we want one component called Navbar, which is a container (aka "class" component, which React Hooks aims to phase out in the next few years) and three "presentational" components (also called "stateless functional components" or "functional components")

2) we want to automatically write these to file, populated by some handy boilerplate code like what we'd get from 'snippets', and 

3) we want the files and components to be named what we called them on the command line, so we can not be annoyed by that.

Now, when we copied our scaffold boilerplate, we could leave the content of the files alone because we didn't need to operate on them. Now, we have to take a different approach because we need to use variables inside templates. 

So, first, lets create two separate templates inside our react-boiler folder:

```Bash
touch cont.js pres.js
```

Inside cont.js, first copy what you normally use for class components. Here's mine: 

```js
import React from 'react';

export default class Something extends React.Component {
  static propTypes = {
    name: React.PropTypes.string,
  };

  constructor(props) {
    super(props);
    this.state = {

    }
  }

  componentDidMount(){

  }

  render() {

    const { } = this.props; 

    return (
      <div></div>
    );
  }
}
```

Inside pres.js:

```js
import React from 'react';

export default function Something (props){

  const { } = props; // I almost always do this

  return (
    <div>

    </div>
  );
};
```

We'll come back to these templates, but for now, lets do some work in our CLI script, which looks like this right now:

```js
#!/usr/bin/env node

const { spawn } = require('child_process')
let input = process.argv
let command = input[2]

const shell = (command) => {

  spawn(command, {shell: true, 
          cwd: process.cwd(), 
          stdio: 'inherit' }
     )
}

let sourceDirect = '/Users/...' // your React-Boiler location 

if(command === 'scaffold'){

  shell(`cp -a ${sourceDirect}/. .`)
}
```

We wanted to declare a container component called "NavBar" as well as three presentational components. Insert a console log above shell and then run our desired react command:

```Bash

react make cont Navbar pres Widget Link Dropdown
```

This should output:

```Bash
[ '/Users/.../.node_modules_global/lib/node_modules/node/bin/node',
  '/Users/.../.node_modules_global/bin/react',
  'make',
  'cont',
  'Navbar',
  'pres',
  'Widget',
  'Link',
  'Dropdown' ]
```

So we have an array with our information, but we need to sort this array so that we know what container and presentational components we need to make.

Lets write a helper function to sort through process.argv:

```js
function sortCompTypes(args){

  let output = []

  let type

  for(let i =0; i < args.length; i++){

    if(args[i] === 'cont' || args[i] === 'pres'){
      type = args[i]
      continue
    }
    if(type){
      output.push([type, args[i]])
    }

  }

  if(!output.length){
    return null
  }
  else{
    return output
  }
}
```
This is indeed a for loop, but we can capture chaining component type requests in any order (no for loop shaming).

Now when you call our full "react make" command, it should return an object that looks like this:

```js
[ [ 'cont', 'Navbar' ],
  [ 'pres', 'Widget' ],
  [ 'pres', 'Link' ],
  [ 'pres', 'Dropdown' ] ]
```

The next piece of the puzzle: lets create two functions that, when we feed them the appropriate part of our array, will generate component templates.

Back inside cont.js, we're going to do something that's going to look a little weird at first. Lets make a function that returns the template code itself as a template literal, inserting the name we processed off the command line as the component name:

```js
module.exports = name => {

return `import React from 'react';

export default class ${name} extends React.Component {
  static propTypes = {
    name: React.PropTypes.string,
  };

  constructor(props) {
    super(props);
    this.state = {

    }
  }

  componentDidMount(){

  }

  render() {

    const { } = this.props;

    return (
      <div></div>
    );
  }
}`
}
```

And pres.js: 

```js
module.exports = (name) => {

return `import React from 'react';

export default function ${name} (props){

  const { } = props;

  return (
    <div>

    </div>
  );
};`
}
```

Notice we don't indent the template literal itself (otherwise the source code we create will look wonky).

Finally, lets put our helper functions, template functions together inside cli.js, writing the strings we created to new files with the same names. 

The cli branch looks like this:

```js
// cli.js

#!/usr/bin/env node

const { spawn } = require('child_process')
let input = process.argv
let command = input[2]
const contComp = require('./cont')
const presComp = require('./pres')
const fs = require("fs");

// ...

if(command === 'make'){

  let components = sortCompTypes(input)

  if(!components){

    console.log('no components specified')  
  }
  else{

    components.forEach(comp => {

      let payload = comp[0] === 'cont' ? 
              contComp(comp[1]) : 
              presComp(comp[1]) ;

      try {
        fs.writeFile(
              `./app/${comp[1]}.js`,
              payload,
              () => {
                let type = comp[0] === 'cont' ? 
                      'container' : 
                      'presentational' ;
                console.log('created ' + type + ' component: ', comp[1]);
              }
            );
      }
      catch(err){
        console.log(err)
      }
    })
  } 
}

function sortCompTypes(args){ // ...
 
```

Breaking down what's happenening in the code above, we import our two template functions at the top. Inside the "make" conditional branch, we process the command line input with our helper function, then iterate through the two dimensional array, processing it appropriately based on the types we inserted into each index. We then call the fs.writefile method, inserting the component name into the file name in the first argument, and writing the payload from the template function in the second argument.

Now, when we navigate to the src folder and call 

```Bash

react make cont Navbar pres Widget Link Dropdown
```

...four component files should populate inside the app folder, titled Navbar.js, Widget.js, Link.js, and Dropdown.js, with the correct boilerplate code written into each.

Finally, lets make a Bash command that will allow us to iterate on this codebase quickly, so we can update it for our next project. This one is a lot less complicated (yes, this is just a fancy Bash alias). 

Based on the fact that we've stored an exact file path to the source directory in our cli.js file, its pretty simple to make a shortcut command to edit the entire template folder in our code editor.

```js
// cli.js 

const { spawn } = require('child_process')
let input = process.argv
let command = input[2]

// ...

const shell = (command) => {

  spawn(command, {shell: true, 
          cwd: process.cwd(), 
          stdio: 'inherit' }
     )
}

// ...

let sourceDirectory = '/Users/...' 

// ...

if(command === 'edit'){

  shell(`subl ${sourceDirectory}`)
}

```

Now, if we call

```Bash
react edit
```

our cli script will automatically launch the template folder in Sublime. For VSC Code the shell argument would just be "code" instead of "subl." 

Mozel tov internet friend! Now you have a hello world React app that you can summon from the command line, that you can completely control and customize, that will save you lots of time searching for and/or writing and/or debugging annoying boilerplate code, and that you can easily iterate over and improve with each project.  

You want to magically summon a full GraphQL API with your hello world React app? Or print out a fully connected React components for your Redux project? Just add it into the src file, or create separate projects, or project parts, and configure them with separate command line calls. Want to configure an entire Redux scaffold with React Router, components controlled by the Redux store via the connect() method, Semantic UI, and Even. More. Buzzwords?!?!? Just add it into the src file. 

Want to make "Goodbye World" spin when your server boots? :p