
Never Write React Boilerplate Ever Again

Modern state management libraries like React and Redux are extremely powerful solutions for building front-end applications, but come with some significant pain points with respect to the amount of boilerplate code required for each library to compile and run.  Between Webpack, Babel, tracking various dependencies, component definitions, component mounting, component lifecycles, and all the related connection code, "This is my React Hello World" has been a running joke/meme/frustration that has grown alongside the popularity of the framework. Indeed, with the release of React Hooks, which explicitly aims to reduce component complexity, "the boilerplate problem" appears to be influencing the evolution of the framework itself.

Borrowing from the Angular ecosystem, which has an officially maintained and extensive CLI, in 2016 the React team released "create-react-app" ("CRA") a library which allowed developers to generate entire React projects, and drove wider adoption of the framework despite its verbosity. Yet, as projects grow, and developers become more experienced in the framework, CRA begins to create another set of problems around its easy of use, which forces users to trade convenince for a decreased ability to control and configure the underlying packages which power their applications. Around the third minute of the first install, it also becomes clear that CRA is quite "bureaucratic," weighing in at 300 mbs, with dozens of libraries, and no less than two separate servers out of the box. It does come with a cool spinning icon when you boot the landing page though! 

Whats more, while it provides a kind of 'command line' solution to one set of problems- initializing a React application- it doesn't necessarily solve another set of problems- writing the application itself. Class components, stateless functional components, life-cycle methods, and now other, advanced functional/hook components- React's boilerplate requirements do not end after hello world is achieved.  One solution which I have used is the "React ES6 Snippets" library, which I like, but grew frustrated at during the third or fourth hour of trying to edit the Sublime codebase.

So, using Node.js and npm, lets build our own CLI that will have methods to generate the required configuration files- Webpack, Babel, package.json, etc- as well as methods to generate some useful component code. This will give us immediate the hello world of CRA without sacrificing flexiblility, so that when we want to tweak our template, or the next time Facebook updates React, we can iterate on the code as we like. 

Sound good? Lets get started.

First step: google "react boilerplate medium" and copy the code from the first thing that pops up. Just kidding! I'll do that for you in a bit, but since we're not just making some boilerplate, but making an application that itself will write source code files, the first thing we need to do is initialize an empty project.

Do:

```bash 
mkdir react-boiler
npm init -y
```

So, what do we want? We want to be able to call the command line and generate a project scaffold: folders, connection code, and all the boilerplate files that a modern React requires inserted into the proper folders. Ideally, we would run our custom bash command, something like "scaffold," then "npm run start-dev," and everything would be ready to go, just like CRA.

So, first things first. In order to make a command available in Bash, we need to install this package globally, and have npm add the command to its "/bin" directory inside the shell PATH. 

Lets create a the file for the scripts we want to run when we run our bash commands:

```bash
$: touch cli.js
```

Then, in the package.json file generated by the npm init call, insert the following under "license":

```json
"bin": {
    "react": "./cli.js"
  },
``` 

Since I don't have "react" in my PATH namespace, I'm just going to have our library callable as "react." 

Then, run the command to install our package globally: 

```bash
$: npm install -g ./
```

To confirm that 'react' was added to node's bin directory, call:

```bash
$: which react
```
Bash should output node's global module directory in your PATH.

Next, lets configure the cli.js file. In order for Bash to know what program needs to execute the script when we call our react command, insert the following at the top of the file:

```shell
#!/usr/bin/env node
```

Put a console log inside cli.js, then call 'react' in the command line, and test that everythings working. 

Its working?  I bet at some point you've wondered how other packages like nodemon get hoisted to run globally from the command line. This is one way. Pretty cool right?

So before we write configuration files, we will want node to create our project folders. 

What if node could run bash commands like "mkdir"? That's sometimes called "shelling out," and there are several node methods we can use to do this. We're going to use "spawn," because that sounds cooler than the other shell out methods. 

In cli.js :

```js
const { spawn } = require('child_process')
let input = process.argv
let command = input[2]
let arg1 = input[3]
```

"Process.argv" is an array that represents the arguments passed into the specific node process from the command line call ("process.argv[0]" being node itself).

We're going to shell out a few times, so lets make a helper method:

```js
const shell = (command) => {

  let myProcess = spawn(command, {shell: true, 
                                  cwd: process.cwd(), 
                                  stdio: 'inherit' }
                        )
  return myProcess
}
````

Now, our shell() method will run any command we pass to it in bash, including "mkdir." 

What are those other lines doing? Since we want to operate on other folders on our machine, we're going to set spawn's working directory as "cwd()."  Next, "stdio: inherit" will let any node instances we create log to the console (without having to do more complicated data configuration). Finally, shell() will return a process object that exposes a method we'll need in a second. 

Now we can program "react scaffold" to make a file directory like this:

```js

if(command === 'scaffold'){

  let makeDirectory = shell('mkdir app app/components public')

}
````

Call "react scaffold" in Bash, and you should see a few folders pop up. 



Webpack webpack.config.js
```js
const { resolve } = require('path')

module.exports = {
  entry: ['babel-polyfill', './app/main'],
  output: {
    path: __dirname,
    filename: './public/bundle.js'
  },
  mode: 'development',
  context: __dirname,
  devtool: 'source-map',
  resolve: {
    extensions: ['.js', '.jsx']
  },
  module: {
    rules: [
      {
        test: /jsx?$/,
        include: resolve(__dirname, './app'),
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  }
}
```


Babel .babelrc

```.json
{
  "presets": ["react", "env", "stage-2"]
}
```

Honestly...I don't really remember what these mean. Something with babel presets?  If you want, google "babelrc medium" and I'm sure whatever the first result is will tell you. Let me know though! Seems important. Also pretty sure it will break at some point so... you should figure that out. 

Moving on! 

package.json

```json
"scripts": {
    "start-dev": "npm run build-watch & npm run start-server",
    "start-server": "nodemon -L --watch server main.js -e html,js,css",
    "build-watch": "webpack -w",
    "start": "echo 'Running server for production - developers, use npm run start:dev for development' && node main"
  },
...
"dependencies": {
    "axios": "^0.18.0",
    "body-parser": "^1.18.2",
    "express": "^4.14.0",
    "react": "^16.3.2",
    "react-dom": "^16.3.2",
    "react-redux": "^5.0.7",
    "react-router-dom": "^4.2.2",
    "redux": "^4.0.0",
    "redux-devtools-extension": "^2.13.7",
    "redux-logger": "^3.0.6",
    "redux-thunk": "^2.2.0"
  },
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-eslint": "^8.2.3",
    "babel-loader": "^7.1.4",
    "babel-polyfill": "^6.26.0",
    "babel-preset-env": "^1.7.0",
    "babel-preset-react": "^6.24.1",
    "babel-preset-stage-2": "^6.24.1",
    "css-loader": "^0.28.11",
    "eslint": "^4.19.1",
    "eslint-config-fullstack": "^5.0.0",
    "eslint-plugin-react": "^7.8.2",
    "style-loader": "^0.21.0",
    "webpack": "^4.29.6",
    "webpack-cli": "^3.2.3"
  }
```

index.html


react root component


Finally, lets make a method that will allow us to iterate on this codebase quickly, so we can update our next project.  


Finally, while we're at it, wouldn't it be cool if we could just pull up a bunch of random React related code in the command line so we wouldn't have to remember the last time we used it?  like remember that one React router thing we did one time?  Yeah that thing, how did I do that again?  Oh yeah just run "react router list" and >>>